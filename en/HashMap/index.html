<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
    <!-- Google Analytics -->
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-209764208-1"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-209764208-1');
    </script>

  <!-- Baidu Tongji -->
    <script async type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?49af1e7917558c9124fc1709797fc578";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <!-- 谷歌站点认证 -->
  <meta name="google-site-verification" content="Vt7J2aQm6nTcvrQzU-Wuee1c_GZ_ESgKvWr_vE_x46o" />
  <!-- 百度站点认证 -->
  <meta name="baidu-site-verification" content="code-WfUpk4GQY3" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="张奶豆"/>
  <meta name="keyword" content="Java,Spring,JVM,Redis,Rabbit Mq,Blog"/>
  <link rel="shortcut icon" href="/img/avatar/roguerabbit.jpg"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/highlight.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/widget.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/rocket.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/signature.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/catalog.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/css/gitalk.css"/>
      <!-- gitalk end -->
    

  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="https://zhangqinzhong.com/en/HashMap/">
  <title>
    
      HashMap - zhangqinzhong
    
  </title>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--light">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'light';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'zhangqinzhong-github-io/zhangqinzhong'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">张勤忠的博客</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">HOME</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              ABOUT
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/archive/">
              
              ARCHIVES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/categories/">
              
              CATEGORIES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              TAGS
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>SEARCH</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <!-- CDN: jsdelivr start -->
  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/img/images/文件00105.png');
      --intro-header-background-image-url-page: url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io//img/images/文件00105.png');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/img/images/文件00105.png');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io//img/images/文件00105.png');
    }
    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url('https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/img/images/文件00105.png'); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/signature.jpg');
      }
    
  </style>
  <!-- CDN: jsdelivr end -->





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#HashMap" title="HashMap">HashMap</a>
              
            </div>
            <h1>HashMap</h1>
            <h2 class="subheading">深入理解HashMap源码</h2>
            <span class="meta">
              Posted by zhangqinzhong on
              2020-11-17
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">29</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">8k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        
<h1>HashMap</h1>
<h2>1.HashMap集合简介</h2>
<p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)</strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>
<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p>
<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>
<p>小结：</p>
<p>特点：</p>
<p>1.存取无序的</p>
<p>2.键和值位置都可以是null，但是键位置只能存在一个null</p>
<p>3.键位置是唯一的，底层的数据结构控制键的</p>
<p>4.jdk1.8前数据结构是：链表 + 数组 jdk1.8之后是 ： 链表 + 数组 + 红黑树</p>
<p>5.阈值(边界值) > 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>
<h2>2.HashMap集合底层的数据结构</h2>
<h3>2.1数据结构概念</h3>
<blockquote>
  <p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370">数据</a>结构是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>存储、组织<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>的方式。数据结构是指相互之间存在一种或多种特定关系的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847">效率</a>。数据结构往往同高效的检索<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025">算法</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853">索引</a>技术有关。</p>
</blockquote>
<p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p>
<p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p>
<p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p>
<h3>2.2HashMap底层的数据结构存储数据的过程</h3>
<p>存储过程如下所示：</p>
<p>使用的代码：</p>&#x3C;!--code￼0-->
<p>说明：</p>
<blockquote>
  <p>
    初始化一个HashMap，向map中存放元素时，代码实现是创建了一个默认长度为16的一维数组，（jdk1.8之前）。jdk1.8时，并没有在new HashMap就开辟空间，而是在首次调用put方法时才创建Node [] table 数组。
    假设添加一个key1，value 1 ，首先调用key1的hashCode()方法，计算出key1的哈希吗，再经过一系列的算法计算后，得到在Node数组中存放的位置，也就是数组下标。如果此下标对应的数组是空的，则添加进去。如果不为空说明出现了hash碰撞，此时比较数组中已经存在的元素和当前添加的元素equals是否相等，相等则覆盖添加。不相等则划出一个节点为链表存储。
  </p>
</blockquote>
<p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p>&#x3C;!--code￼1-->
<p>2.面试题：当两个对象的hashCode相等时会怎么样？</p>&#x3C;!--code￼2-->
<p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p>&#x3C;!--code￼3-->
<p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p>&#x3C;!--code￼4-->
<p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 > 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p>
<p>
  <img src="%E5%93%88%E5%B8%8C%E8%A1%A8.jpg" alt="哈希表">
</p>
<p><strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p>
<p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p>
<p><strong>7.总结：</strong></p>
<p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p>
<p>
  <img src="1.png" alt="1">
</p>
<p>说明：</p>
<p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。</p>
<p>2.threshold( 临界值) =capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p>
<h2>3.HashMap继承关系</h2>
<p>HashMap继承关系如下图所示：</p>
<p>
  <img src="1.bmp" alt="1">
</p>
<p>说明：</p>
<ul>
  <li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li>
  <li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li>
  <li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>
</ul>
<p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。</p>&#x3C;!--code￼5-->
<h2>4.HashMap集合类的成员</h2>
<h3>4.1成员变量</h3>
<p>1.序列化版本号</p>&#x3C;!--code￼6-->
<p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p>&#x3C;!--code￼7-->
<p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong></p>
<p>HashMap构造方法还可以指定集合的初始化容量大小：</p>&#x3C;!--code￼8-->
<p>根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>
<p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&#x26;(length-1)，而实际上hash%length等于hash&#x26;(length-1)的前提是length是2的n次幂。</p>
<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1 实际就是n个1；</p>
<p>举例：</p>
<p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p>&#x3C;!--code￼9-->&#x3C;!--code￼10-->
<p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong></p>
<p>小结：</p>&#x3C;!--code￼11-->&#x3C;!--code￼12-->&#x3C;!--code￼13-->&#x3C;!--code￼14-->
<p>说明：</p>
<p>
  由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。
  下面分析这个算法：
  1)、首先，为什么要对cap做减1操作。int n = cap - 1;
  这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。
  下面看看这几个无符号右移操作：
  2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是 1（最后有个n+1的操作）。
  这里只讨论n不等于0的情况。
</p>
<p>3）、注意：<strong>|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p>&#x3C;!--code￼15-->
<p>由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p>&#x3C;!--code￼16-->
<p><strong>第二次右移</strong> ：</p>&#x3C;!--code￼17-->
<p>注意，这个n已经经过了<code>n |= n >>> 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p>&#x3C;!--code￼18-->
<p><strong>第三次右移</strong> :</p>&#x3C;!--code￼19-->
<p>
  这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。
  以此类推
  注意，容量最大也就是32bit的正数，因此最后n |= n >>> 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。
  请看下面的一个完整例子：
</p>
<p>
  <img src="image-20191115151657917.png" alt="image-20191115151657917">
</p>
<p>注意，得到的这个capacity却被赋值给了threshold。</p>&#x3C;!--code￼20-->
<p>3.默认的负载因子，默认值是0.75</p>&#x3C;!--code￼21-->
<p>4.集合最大容量</p>&#x3C;!--code￼22-->
<p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>)</p>&#x3C;!--code￼23-->
<p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p>
<p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8：</p>
<p>在HashMap中有一段注释说明： 我们继续往下看 :</p>&#x3C;!--code￼24-->
<p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p>
<p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p>
<p>这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。</p>
<p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p>
<p>补充：</p>
<p>1）.</p>&#x3C;!--code￼25-->
<p>
  <img src="image-20191115161055901.png" alt="image-20191115161055901">
</p>&#x3C;!--code￼26-->
<p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p>&#x3C;!--code￼27-->
<p><strong>6.当链表的值小于6则会从红黑树转回链表</strong></p>&#x3C;!--code￼28-->
<p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p>&#x3C;!--code￼29-->
<p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong></p>&#x3C;!--code￼30-->
<p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&#x3C;K,V>类型。从jdk1.8之后是Node&#x3C;K,V>类型。只是换了个名字，都实现了一样的接口：Map.Entry&#x3C;K,V>。负责存储键值对数据的。</p>
<p>9、用来存放缓存</p>&#x3C;!--code￼31-->
<p><strong>10、 HashMap中存放元素的个数(重点)</strong></p>&#x3C;!--code￼32-->
<p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p>
<p>11、 用来记录HashMap的修改次数</p>&#x3C;!--code￼33-->
<p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子)</p>&#x3C;!--code￼34-->
<p><strong>13、 哈希表的加载因子(重点)</strong></p>&#x3C;!--code￼35-->
<p><strong>说明：</strong></p>
<p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p>
<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p>
<p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p>
<p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p>&#x3C;!--code￼36-->
<p>2.为什么加载因子设置为0.75,初始化临界值是12？</p>
<p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p>
  <img src="image-20191115173553375.png" alt="image-20191115173553375">
</p>
<p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p>
<p>举例：</p>&#x3C;!--code￼37-->
<p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p>
<ul>
  <li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size>=threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li>
</ul>
<h3>4.2构造方法</h3>
<p>HashMap 中重要的构造方法，它们分别如下：</p>
<p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。</p>&#x3C;!--code￼38-->
<p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。</p>&#x3C;!--code￼39-->
<p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。</p>&#x3C;!--code￼40-->
<p>说明：</p>
<p>对于 this.threshold = tableSizeFor(initialCapacity); 疑问解答：</p>
<blockquote>
  <p>
    tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指定初始化容量大的最小的2的n次幂。这点上述已经讲解过。
    但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：
  </p>
  <p>
    this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;
    这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。
    但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解
  </p>
</blockquote>
<p>4、包含另一个“Map”的构造函数</p>&#x3C;!--code￼41-->
<p>最后调用了putMapEntries，来看一下方法实现：</p>&#x3C;!--code￼42-->
<p>注意：</p>
<p>float ft = ((float)s / loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p>
<p>s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。</p>
<p>例如：原来集合的元素个数是6个，那么6/0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p>
<h3>4.3成员方法</h3>
<h4>4.3.1增加方法</h4>
<p>put方法是比较复杂的，实现步骤大致如下：</p>
<p>1）先通过hash值计算出key映射到哪个桶；</p>
<p>2）如果桶上没有碰撞冲突，则直接插入；</p>
<p>3）如果出现碰撞冲突了，则需要处理冲突：</p>&#x3C;!--code￼43-->&#x3C;!--code￼44-->
<p>4）如果桶中存在重复的键，则为该键替换新值value；</p>
<p>5）如果size大于阈值threshold，则进行扩容；</p>
<p>具体的方法如下：</p>&#x3C;!--code￼45-->
<p>说明：</p>&#x3C;!--code￼46-->
<p>2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。</p>&#x3C;!--code￼47-->
<p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p>
<p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &#x26; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &#x26; (length-1)运算等价于对 length 取模，也就是hash%length，但是&#x26;比%具有更高的效率。比如 n % 32 = n &#x26; (32 -1)。}</p>
<p><strong>解读上述hash方法：</strong></p>
<p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p>
<p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的 hash值。计算过程如下所示：</p>&#x3C;!--code￼48-->
<p>在putVal函数中使用到了上述hash函数计算的哈希值：</p>&#x3C;!--code￼49-->
<p>计算过程如下所示：</p>&#x3C;!--code￼50-->&#x3C;!--code￼51-->&#x3C;!--code￼52-->&#x3C;!--code￼53-->&#x3C;!--code￼54-->
<p>
  <img src="image-20191114193730911.png" alt="image-20191114193730911">
</p>
<p>简单来说就是：</p>
<ul>
  <li>
    <p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p>
    <p><strong>问题：为什么要这样操作呢？</strong></p>
    <p>如果当n即数组长度很小，假设是16的话，那么n-1即为 ---》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>&#x3C;!--code￼55--></li>
  <li>
    <p>(n-1) &#x26; hash = -> 得到下标 (n-1) n表示数组长度16，n-1就是15</p>
  </li>
  <li>
    <p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p>
  </li>
</ul>
<p>现在看putVal()方法，看看它到底做了什么。</p>
<p>主要参数：</p>
<ul>
  <li>hash key的hash值</li>
  <li>key 原始Key</li>
  <li>value 要存放的值</li>
  <li>onlyIfAbsent 如果true代表不更改现有的值</li>
  <li>evict 如果为false表示table为创建状态</li>
</ul>
<p>putVal()方法源代码如下所示：</p>&#x3C;!--code￼56-->
<h4>4.3.2将链表转换为红黑树的treeifyBin方法</h4>
<p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p>&#x3C;!--code￼57-->
<p>treeifyBin方法如下所示：</p>&#x3C;!--code￼58-->
<p>小结：上述操作一共做了如下几件事：</p>
<p>1.根据哈希表中元素个数确定是扩容还是树形化</p>
<p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p>
<p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p>
<h4>4.3.3扩容方法_resize</h4>
<h5>4.3.3.1扩容机制</h5>
<p>想要了解HashMap的扩容机制你要有这两个问题</p>
<ul>
  <li>1.什么时候才需要扩容</li>
  <li>2.HashMap的扩容是什么</li>
</ul>
<p><strong>1.什么时候才需要扩容</strong></p>
<p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p>
<p><strong>补充：</strong></p>
<p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p>
<p><strong>2.HashMap的扩容是什么</strong></p>
<p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&#x26;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到"<strong>原位置+旧容量</strong>"这个位置。</p>
<p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p>
<p>
  <img src="image-20191117110812839.png" alt="image-20191117110812839">
</p>
<p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p>
  <img src="image-20191117110934974.png" alt="image-20191117110934974">
</p>
<p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到"<strong>原位置+旧容量</strong>"这个位置。</p>
<p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图：</p>
<p>
  <img src="image-20191117111211630.png" alt="image-20191117111211630">
</p>
<p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p>
<h5>4.3.3.2源码resize方法的解读</h5>
<p>下面是代码的具体实现：</p>&#x3C;!--code￼59-->
<h4>4.3.4 删除方法(remove)</h4>
<p>理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p>
<p>删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。</p>
<p>删除remove方法：</p>&#x3C;!--code￼60-->
<p>removeNode方法：</p>&#x3C;!--code￼61-->
<h4>4.3.5查找元素方法(get)</h4>
<p>查找方法，通过元素的Key找到Value。</p>
<p>代码如下：</p>&#x3C;!--code￼62-->
<p>get方法主要调用的是getNode方法，代码如下：</p>&#x3C;!--code￼63-->
<p>小结：</p>
<p>1.get方法实现的步骤：</p>&#x3C;!--code￼64-->&#x3C;!--code￼65-->&#x3C;!--code￼66-->&#x3C;!--code￼67-->&#x3C;!--code￼68-->
<p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p>&#x3C;!--code￼69-->
<p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p>
<p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p>&#x3C;!--code￼70-->&#x3C;!--code￼71-->
<h4>4.3.6遍历HashMap集合几种方式</h4>
<p>1、分别遍历Key和Values</p>
<p>
  <img src="image-20191117160455507.png" alt="image-20191117160455507">
</p>
<p>2、使用Iterator迭代器迭代</p>
<p>
  <img src="image-20191117160627369.png" alt="image-20191117160627369">
</p>
<p>3、通过get方式（不建议使用）</p>
<p>
  <img src="image-20191117160733756.png" alt="image-20191117160733756">
</p>
<p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p>
<p>4.jdk8以后使用Map接口中的默认方法：</p>&#x3C;!--code￼72-->
<p>遍历代码：</p>&#x3C;!--code￼73-->
<h2>5.如何设计多个非重复的键值对要存储HashMap的初始化？</h2>
<h3>5.1HashMap的初始化问题描述</h3>&#x3C;!--code￼74-->&#x3C;!--code￼75-->
<p>《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。</p>
<p>
  <img src="2.bmp" alt="2">
</p>
<p>那么，为什么要这么建议？你有想过没有。</p>
<p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。</p>
<p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p>
<p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p>
<h3>5.2HashMap中容量的初始化</h3>
<p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p>
<p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p>
<p>
  <img src="image-20191117165438726.png" alt="image-20191117165438726">
</p>
<p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p>
<p>如果我们通过<strong>initialCapacity/ 0.75F + 1.0F</strong>计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p>
<p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity/0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p>
<p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p>
<p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p>
<p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p>
<p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>。</p>
<blockquote>
  <p>资料来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nJ411J7AA?p=15">https://www.bilibili.com/video/BV1nJ411J7AA?p=15</a></p>
</blockquote>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/en/RandomAccess/" data-toggle="tooltip" data-placement="top" title="RandomAccess">&larr; Previous Post</a>
          </li>
          
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=HashMap&body=Hi,I found this website and thought you might like it https://zhangqinzhong.com/en/HashMap/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <script src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '807759333c17a44710d7',
      clientSecret: 'e5a2fb060b16857c3b48830e22762dbb2b94aac3',
      repo: 'zhangqinzhong.github.io',
      owner: 'zhangqinzhong',
      admin: 'zhangqinzhong',
      id: 'Tue Nov 17 2020 17:24:16 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">HashMap</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.HashMap集合简介</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">2.HashMap集合底层的数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">2.1数据结构概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">2.2HashMap底层的数据结构存储数据的过程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">3.HashMap继承关系</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">4.HashMap集合类的成员</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">4.1成员变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">4.2构造方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text">4.3成员方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.1.</span> <span class="toc-nav-text">4.3.1增加方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.2.</span> <span class="toc-nav-text">4.3.2将链表转换为红黑树的treeifyBin方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.3.</span> <span class="toc-nav-text">4.3.3扩容方法_resize</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.3.1.</span> <span class="toc-nav-text">4.3.3.1扩容机制</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.3.2.</span> <span class="toc-nav-text">4.3.3.2源码resize方法的解读</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.4.</span> <span class="toc-nav-text">4.3.4 删除方法(remove)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.5.</span> <span class="toc-nav-text">4.3.5查找元素方法(get)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">1.4.3.6.</span> <span class="toc-nav-text">4.3.6遍历HashMap集合几种方式</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">5.如何设计多个非重复的键值对要存储HashMap的初始化？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">5.1HashMap的初始化问题描述</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">5.2HashMap中容量的初始化</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#HashMap" title="HashMap">HashMap</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>FRIENDS</h5>
        <ul class="list-inline">

          
          <li>
            <a href="https://baidu.com" target="_blank">百度</a>
          </li>
          
          <li>
            <a href="https://google.com" target="_blank">Google</a>
          </li>
          
          <li>
            <a href="https://www.bilibili.com/" target="_blank">bilibili</a>
          </li>
          
          <li>
            <a href="https://weibo.com/" target="_blank">新浪微博</a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      icon: 'ℬ'
      // icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/zhangqinzhong">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://twitter.com/zhangqinzhong">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://www.instagram.com/springbreezeboy">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://www.facebook.com/David John">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          
            <li>
              <a target="_blank" href="https://www.zhihu.com/people/zhangqinzhong">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa  fa-stack-1x fa-inverse">知</i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="http://weibo.com/6213306199">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          zhangqinzhong
          2021
<!--           <br> -->
<!--           Theme by -->
<!--           <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a> -->
<!--           <span style="display: inline-block; margin: 0 5px;"> -->
<!--             <i class="fa fa-heart"></i> -->
<!--           </span> -->
<!--           re-Ported by -->
<!--           <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a> -->
<!--           | -->
<!--           <iframe style="margin-left: 2px; margin-bottom:-5px;"  -->
<!--           frameborder="0" scrolling="0" width="91px" height="20px"  -->
<!--           src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe> -->
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/jquery.min.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/bootstrap.min.js"></script>

  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/hux-blog.min.js"></script>

  <!-- catalog -->
  <script async="true" type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/catalog.js"></script>

  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/mouseclick.js"  content='奶豆~,喵喵~,奶豆是我的猫~,喵~,吃饭~,睡觉~,跑酷~,搞破坏~,洗澡~' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033' ></script>
    <!-- Mouseclick -->
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/ribbonDynamic.js"></script>
  

  




  <!-- CDN: jsdelivr start -->
  <script async="async" type="text/javascript">
    let imgsUrl = document.getElementsByTagName("img");
    let imgUrl = Array.from(imgsUrl);

    let jsdelivr = "https://cdn.jsdelivr.net/gh/";
    let gh = "zhangqinzhong";
    let ghPages = gh + ".github.io";
    let pagePath = "en/HashMap/";
    let jsdelivrurl;
    if (pagePath.indexOf("index.html") != -1) {
      jsdelivrurl = jsdelivr + gh + "/" + ghPages;
    } else {
      jsdelivrurl = jsdelivr + gh + "/" + ghPages + "/" + pagePath;
    }
    imgUrl.forEach(item => {
      let oldUrl = item.getAttribute("src");
      let newUrl = oldUrl.replace(oldUrl, jsdelivrurl + oldUrl).replace("..", "");
      item.setAttribute("src", newUrl);
    });
  </script>
  <!-- CDN: jsdelivr end -->



  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("https://zhangqinzhong.com/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="SEARCH..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            
              imgUrl = 'https://cdn.jsdelivr.net/gh/zhangqinzhong/zhangqinzhong.github.io' + imgUrl;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
